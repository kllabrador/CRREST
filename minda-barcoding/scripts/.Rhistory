source2 = "BOLD") %>%
rename (scientific_name = species) %>%
distinct()
# Check unique species count
species_list_full <- c(MAF.species.list$scientific_name, BOLD.species.list$scientific_name) %>%
unique() %>% sort ()
species_list_unidentified <- species_list_full[which (grepl("sp.", species_list_full, fixed=T))]
species_list_identified_count <- length (species_list_full) - length (species_list_unidentified)
species_list_identified_count
# Join the two datasheets
master_list <- full_join (MAF.species.list, BOLD.species.list, by = c("scientific_name", "barcode")) %>%
mutate (data = case_when (barcode %in% "Y" ~ "with barcodes",
grepl ("MSD", observation) ~ "MSD",
T ~ "FVC"))
# Check for discrepancies between the two datasets.
t <- master_list %>% filter (barcode == "Y")
write.csv(t, paste0(outdir, "master_list.csv"))
aln.metadata <- data.frame (label = names(aln.fas)) %>%
separate_wider_delim(label,
delim = "|",
names = c("process_id", "taxa_id", "sample_id", "bin", "accession_no"),
cols_remove = F
) %>%
separate_wider_delim(taxa_id,
delim = "_",
names = c("genus", "species"),
too_few = "align_start",
cols_remove = F
) %>%
mutate (scientific_name = str_replace(taxa_id, "_", " ")
) %>%
left_join(genus.list, by = "genus")
genus.list <- data.bkp %>%
select (genus) %>%
distinct
master_list
genus.list <- master_list %>%
select (genus) %>%
distinct
genus.list
genus.list <- master_list %>%
select (genus) %>%
distinct
aln.metadata <- data.frame (label = names(aln.fas)) %>%
separate_wider_delim(label,
delim = "|",
names = c("process_id", "taxa_id", "sample_id", "bin", "accession_no"),
cols_remove = F
) %>%
separate_wider_delim(taxa_id,
delim = "_",
names = c("genus", "species"),
too_few = "align_start",
cols_remove = F
) %>%
mutate (scientific_name = str_replace(taxa_id, "_", " ")
) %>%
left_join(genus.list, by = "genus")
aln.metadata
data.bkp <- as_tibble.DNAbin(aln.fas) %>%
full_join(aln.metadata)
# Create the sequence list.
querySeq <- aln.fas%>%
as.dna %>%
as.list %>%
map(~.x %>%
toupper %>%
str_flatten(collapse="")
)
??as.dna
pacman::p_load (
# Data wrangling
tidyverse, janitor,
# Plotting
cowplot,
# Interfacing with sequence data
ape, bioseq, haplotypes, phangorn,
# Statistical calculations
rstatix)
# Create the sequence list.
querySeq <- aln.fas%>%
as.dna %>%
as.list %>%
map(~.x %>%
toupper %>%
str_flatten(collapse="")
)
querySeq
querySeq %>% length()
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq
, ~bold_identify(sequences=.x
, db="COX1")
)
pacman::p_load (
# Data wrangling
tidyverse, janitor,
# Plotting
cowplot,
# Interfacing with sequence data
ape, bold, bioseq, haplotypes, phangorn,
# Statistical calculations
rstatix)
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq
, ~bold_identify(sequences=.x
, db="COX1")
)
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq
, ~bold_identify(sequences=.x
, db="COX1")
)
querySeq
?bold_identify
BOLD.ID <- map(querySeq,
~bold_identify(sequences=.x
, db="COX1")
)
querySeq
names(querySeq)
names(querySeq)
names(querySeq) %>%
str_split("\\|")[[1]][3]
names(querySeq) %>%
str_split(., "\\|")[[1]][3]
names(querySeq) %>%
str_split(., "\\|")
t <- names(querySeq)
t
str(t)
?str_extract
str_extract (t, "\\|")
t
sapply(str_split(t, "\\|"), function (x) x[3])
# Change names of querySeq
new.names <- names(querySeq) %>%
sapply (str_split(., "\\|"), function (x) x[3])
# Change names of querySeq
new.names <- names(querySeq) %>%
sapply (str_split(., "\\|"), function (x) x[3])
# Change names of querySeq
new.names <- names(querySeq) %>%
sapply (str_split("\\|"), function (x) x[3])
?str_split
# Change names of querySeq
new.names <- names(querySeq) %>%
sapply (str_split(pattern = "\\|"), function (x) x[3])
# Change names of querySeq
new.names <-
sapply (str_split(names(querySeq), "\\|"), function (x) x[3])
new.names
# Change names of querySeq
new.names <- sapply (str_split(names(querySeq), "\\|"), function (x) x[3])
names(querySeq) <- new.names
querySeq
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq,
~bold_identify(sequences=.x
, db="COX1")
)
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq,
~bold_identify(sequences=.x
, db='COX1')
)
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq,
~bold_identify(sequences=.x
, db='COX1_SPECIES')
)
querySeq[1:5]
# Query the sequences to BOLD. Runtime depends on the data size (no. of sequences, sequence length).
BOLD.ID <- map(querySeq[1:5],
~bold_identify(sequences=.x
, db='COX1_SPECIES')
)
BOLD.ID
# Determine the sequences that were not identified
no.ID <- map(BOLD.ID
, ~.x[[1]]) %>%
keep(is.null) %>% names()
no.ID
# Coerce the list into a data frame.
BOLD.ID.df <- map(BOLD.ID
, ~.x[[1]]) %>%
plyr::ldply(.id="SampleID")
BOLD.ID.df
# Check unique species
species <- BOLD.ID.df %>%
filter (similarity> 0.98) %>% # interspecific threshold for COI (see Ward 2005)
pull (taxonomicidentification) %>%
unique
print(species) # In instances that there are several hits for species, you can extract the haplotype sequence information and ID using NCBI-BLAST.
BOLD.ID.df
list.files()
list.files(outdir)
outdir
# Save the data.frame for future reference.
write.csv(BOLD.ID.df, paste0(outdir, "BOLD-ID.csv"))
species.count <- data.bkp %>%
select (scientific_name) %>%
distinct %>%
nrow()
genus.count <- data.bkp %>%
select (genus) %>%
distinct %>%
nrow()
family.count <- data.bkp %>%
select (family) %>%
distinct %>%
nrow()
data.bkp
genus.list <- master_list %>%
select (family, genus) %>%
distinct
aln.metadata <- data.frame (label = names(aln.fas)) %>%
separate_wider_delim(label,
delim = "|",
names = c("process_id", "taxa_id", "sample_id", "bin", "accession_no"),
cols_remove = F
) %>%
separate_wider_delim(taxa_id,
delim = "_",
names = c("genus", "species"),
too_few = "align_start",
cols_remove = F
) %>%
mutate (scientific_name = str_replace(taxa_id, "_", " ")
) %>%
left_join(genus.list, by = "genus")
data.bkp <- as_tibble.DNAbin(aln.fas) %>%
full_join(aln.metadata)
species.count <- data.bkp %>%
select (scientific_name) %>%
distinct %>%
nrow()
genus.count <- data.bkp %>%
select (genus) %>%
distinct %>%
nrow()
family.count <- data.bkp %>%
select (family) %>%
distinct %>%
nrow()
family.count
genus.count
species.count
family_count <- master_list %>%
group_by (family, data) %>%
summarize (count = n()) %>%
mutate (sum = cumsum(count),
max_sum = max (sum)) %>%
arrange (desc(max_sum))
# Create a character vector to relevel the family based on counts.
family_relevel <- family_count$family %>%
unique()
# Relevel family.
family_count <- family_count %>%
mutate (family_relevel = factor(family, levels = family_relevel))
# Split data frame into two:
partition1 <- family_count[1:74,]
partition2 <- family_count[77:111,]
partition3 <- family_count[112:nrow(family_count),]
plot_family_count <- function(family_count_df_parition) {
plot <-
ggplot (family_count_df_parition,
aes (x = family_relevel,
y = count,
fill = data)
) +
geom_col(col = "black",
position = "stack") +
theme_classic()  +
labs (x = "Family",
y = "Number of species") +
scale_y_continuous(expand = c(0,0)) +
theme(axis.text.x = element_text(angle=90,
vjust = 0.25,
hjust = 1,
size = 8)) +
#scale_fill_brewer(palette = "Set3") +
scale_fill_brewer (palette = "Set3") +
theme(legend.position = "top",
legend.title = element_blank())
return(plot)
}
plot_family_count_partition1 <- plot_family_count(partition1)
plot_family_count_partition2 <- plot_family_count(partition2)
plot_family_count_partition3 <- plot_family_count(partition3)
require(ggpubr)
plot_family_count_total <-
ggpubr::ggarrange(plot_family_count_partition1 +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition2 +
theme (axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition3 +
theme (axis.title.y = element_blank()) +
scale_y_continuous(breaks = c(0,1)),
nrow = 3,
heights = c(2,1,0.75),
common.legend = T) %>%
annotate_figure(left = text_grob("Number of species", rot = 90))
ggexport(plot_family_count_total,
filename = paste0(outdir,
"fig2.family-count_barplot.png"),
height = 2500,
width = 2100,
res = 300
)
plot_family_count <- function(family_count_df_parition) {
plot <-
ggplot (family_count_df_parition,
aes (x = family_relevel,
y = count,
fill = data)
) +
geom_col(col = "black",
position = "stack") +
theme_classic()  +
labs (x = "Family",
y = "Number of species") +
scale_y_continuous(expand = c(0,0)) +
theme(axis.text.x = element_text(angle=45,
vjust = 1,
hjust = 1,
size = 8)) +
#scale_fill_brewer(palette = "Set3") +
scale_fill_brewer (palette = "Set3") +
theme(legend.position = "top",
legend.title = element_blank())
return(plot)
}
plot_family_count_partition1 <- plot_family_count(partition1)
plot_family_count_partition2 <- plot_family_count(partition2)
plot_family_count_partition3 <- plot_family_count(partition3)
require(ggpubr)
plot_family_count_total <-
ggpubr::ggarrange(plot_family_count_partition1 +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition2 +
theme (axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition3 +
theme (axis.title.y = element_blank()) +
scale_y_continuous(breaks = c(0,1)),
nrow = 3,
heights = c(2,1,0.75),
common.legend = T) %>%
annotate_figure(left = text_grob("Number of species", rot = 90))
ggexport(plot_family_count_total,
filename = paste0(outdir,
"fig2.family-count_barplot.png"),
height = 2500,
width = 2100,
res = 300
)
plot_family_count <- function(family_count_df_parition) {
plot <-
ggplot (family_count_df_parition,
aes (x = family_relevel,
y = count,
fill = data)
) +
geom_col(col = "black",
position = "stack") +
theme_classic()  +
labs (x = "Family",
y = "Number of species") +
scale_y_continuous(expand = c(0,0)) +
theme(axis.text.x = element_text(angle=45,
vjust = 1,
hjust = 1,
size = 10)) +
#scale_fill_brewer(palette = "Set3") +
scale_fill_brewer (palette = "Set3") +
theme(legend.position = "top",
legend.title = element_blank())
return(plot)
}
plot_family_count_partition1 <- plot_family_count(partition1)
plot_family_count_partition2 <- plot_family_count(partition2)
plot_family_count_partition3 <- plot_family_count(partition3)
require(ggpubr)
plot_family_count_total <-
ggpubr::ggarrange(plot_family_count_partition1 +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition2 +
theme (axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition3 +
theme (axis.title.y = element_blank()) +
scale_y_continuous(breaks = c(0,1)),
nrow = 3,
heights = c(2,1,0.75),
common.legend = T) %>%
annotate_figure(left = text_grob("Number of species", rot = 90))
ggexport(plot_family_count_total,
filename = paste0(outdir,
"fig2.family-count_barplot.png"),
height = 2500,
width = 2100,
res = 300
)
plot_family_count <- function(family_count_df_parition) {
plot <-
ggplot (family_count_df_parition,
aes (x = family_relevel,
y = count,
fill = data)
) +
geom_col(col = "black",
position = "stack") +
theme_classic()  +
labs (x = "Family",
y = "Number of species") +
scale_y_continuous(expand = c(0,0)) +
theme(axis.text.x = element_text(angle=45,
vjust = 1,
hjust = 1,
size = 9)) +
#scale_fill_brewer(palette = "Set3") +
scale_fill_brewer (palette = "Set3") +
theme(legend.position = "top",
legend.title = element_blank())
return(plot)
}
plot_family_count_partition1 <- plot_family_count(partition1)
plot_family_count_partition2 <- plot_family_count(partition2)
plot_family_count_partition3 <- plot_family_count(partition3)
require(ggpubr)
plot_family_count_total <-
ggpubr::ggarrange(plot_family_count_partition1 +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition2 +
theme (axis.title.x = element_blank(),
axis.title.y = element_blank()),
plot_family_count_partition3 +
theme (axis.title.y = element_blank()) +
scale_y_continuous(breaks = c(0,1)),
nrow = 3,
heights = c(2,1,0.75),
common.legend = T) %>%
annotate_figure(left = text_grob("Number of species", rot = 90))
ggexport(plot_family_count_total,
filename = paste0(outdir,
"fig2.family-count_barplot.png"),
height = 2500,
width = 2100,
res = 300
)
species.dist <- files.csv$`divergence_within-species.csv` %>%
mutate (level = "species")
genus.dist <- files.csv$`divergence_wthin-genus.csv` %>%
mutate (level = "genus")
family.dist <- files.csv$`divergence_within-family.csv` %>%
mutate (level = "family")
dist.df <- rbind (species.dist,
genus.dist,
family.dist) %>%
mutate (level = fct_relevel(level, "species", "genus", "fanily"))
barcode_gap <- files.csv$barcode_gap_analysis.csv %>%
pivot_longer(cols = c(mean_intra_sp,max_intra_sp, distance_to_nn),
names_to = "comp",
values_to = "dist"
) %>%
na.omit() %>%
mutate (comp = case_when (grepl("max_intra_sp", comp) ~ "intraspecific (max)",
grepl("distance_to_nn", comp) ~ "interspecific (NN)",
T ~ comp))
barcode_gap.stats <- barcode_gap %>%
group_by(comp) %>%
get_summary_stats(dist)
bin_concordant <- files.csv$`binDiscordance-CONCORDANT-BINS.csv`
bin_discordant <- files.csv$`binDiscordance-DISCORDANT-BINS.csv`
bin_singleton <- files.csv$`binDiscordance-SINGLETON-BINS.csv`
OTU_cluster <- files.csv$cluster_sequence.csv
discordance_case1 <- OTU_cluster %>%
group_by(otu) %>%
filter (length (unique (taxon)) > 1 ) %>%
ungroup() %>%
select (otu, taxon) %>%
distinct
discordance_case2 <- OTU_cluster %>%
group_by(taxon) %>%
filter (length (unique (otu)) > 1 ) %>%
ungroup() %>%
select (otu, taxon) %>%
distinct %>%
arrange (taxon)
# Identify different species that were binned in the same OTU.
discordance_case1 <- OTU_cluster %>%
group_by(otu) %>%
filter (length (unique (taxon)) > 1 ) %>%
ungroup() %>%
select (otu, taxon) %>%
distinct
discordance_case1
# Identify same species that were binned in separate OTUs.
discordance_case2 <- OTU_cluster %>%
group_by(taxon) %>%
filter (length (unique (otu)) > 1 ) %>%
ungroup() %>%
select (otu, taxon) %>%
distinct %>%
arrange (taxon)
discordance_case2
